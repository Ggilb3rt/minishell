What is a shell?

The shell is a program that interacts with the user through a terminal or takes the input from a file and executes a
sequence of commands that are passed to the Operating System.

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
------------------------------------------------------------------------------------------------------------------------
Writing a shell :

- Get into a loop the input of the user
- Parsing of the user input
- Executing the command
- builtins
- environment

https://segfault42.github.io/posts/minishell/
------------------------------------------------------------------------------------------------------------------------
What is a shell program?

A shell program is an application that allows interacting with the computer. In a shell the user can run programs and
also redirect the input to come from a file and output to come from a file. Shells also provide programming
constructions such as if, for, while, functions, variables etc. Additionally, shell programs offer features such
as line editing, history, file completion, wildcards, environment variable expansion, and programming constructions.

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
------------------------------------------------------------------------------------------------------------------------
What are the different parts of a shell?

The shell implementation is divided into three parts : The parser, the executor and the shell subsystems.
- The parser will reads the command line and puts it into a data structure called Command Table that will store the
commands that will be executed.
- The executor will take the command table generated by the parser and for every simple command in the array it will
create a new process. It will also if necessary create pipes to communicate the output of one process to the input
of the next one. Additionally it will redirect the standard input, standard output and standard error if there are any
redirections.
            _____________________________________
           |  ___   ___   ___   ____             |
           V |   V |   V |   V |    V            |
            A  |  B  |  C  |  D  >  outfile  <  infile  2>  errfile

- Other subsystems that complete your shell are : environment variables, wildcards, subshells (arguments between ''
are executed and the output is sent as input to the shell.

1. The shell reads its input from a file.
2. The shell breaks the input into tokens: words and operators
3. The shell parses the input into simple commands and compound commands.
4. The shell performs various expansions (separately) on different parts of each command, resulting in a list of
pathnames and fields to be treated as a command and arguments.
5. The shell performs redirection and removes redirection operators and their operands from the parameter list.
6. The shell executes a function, built-in, executable file, or script, giving the names of the arguments as positional
parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of
the script) as the positional parameter numbered 0.
7. The shell optionally waits for the command to complete and collects the exit status.


https://pubs.opengroup.org/onlinepubs/009604499/utilities/xcu_chap02.html
------------------------------------------------------------------------------------------------------------------------
How to implement a parser?

A parser is divided into two parts: A Lexical Analyzer or Lexer takes the input characters and puts the characters
together into words called tokens, and a parser that processes the tokens according to a grammar and build the
command table.

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
------------------------------------------------------------------------------------------------------------------------
How to declare the structures Command and SimpleCommand?

The 'Command Table' is an array of 'simpleCommand' structs. A 'simpleCommand' struct contains members for the command
and arguments of a single entry in the pipeline. The parser will look also at the command line and determine if there
is anny input or output redirection based on symbols present in the command (i.e. < infile or > outfile).

Here is an example of a command and the 'CommandTable' it generates:

command : ls -al | grep me > file 1

command table :
    SimpleCommand array
    ______________________________
    | 0: | ls     | -al   | NULL |
    ------------------------------
    | 1: | grep   | me    | NULL |
    ------------------------------

    IO Redirection:
    _____________________________________________
    | in: default  | out: file1  | err: default  |
    ---------------------------------------------

// Command Data Structure

// Describes a simple command and arguments
struct SimpleCommand {
        // Available space for arguments currently preallocated
        int _numberOfAvailableArguments;

        // Number of arguments
        int _numberOfArguments;

        // Array of arguments
        char ** _arguments;

        SimpleCommand();
        void insertArgument( char * argument );
};

// Describes a complete command with the multiple pipes if any
// and input/output redirection if any.
struct Command {
        int _numberOfAvailableSimpleCommands;
        int _numberOfSimpleCommands;
        SimpleCommand ** _simpleCommands;
        char * _outFile;
        char * _inputFile;
        char * _errFile;
        int _background;

        void prompt();
        void print();
        void execute();
        void clear();

        Command();
        void insertSimpleCommand( SimpleCommand * simpleCommand );

        static Command _currentCommand;
        static SimpleCommand *_currentSimpleCommand;
};

The constructor 'SimpleCommand::SimpleCommand' constructs a simple empty command.
The method 'SimpleCommand::insertArgument(char *argument)' inserts a new argument into the SimpleCommand and enlarges
the _arguments array if necessary. It also makes sure that the last element is NULL since that is required for the
exec() system call.

The constructor 'Command::Command()' constructs and empty command that will be populated with the method
Command::'insertSimpleCommand(SimpleCommand *simpleCommand)'. insertSimpleCommand also enlarges the array
_simpleCommands if necessary. The variables _outFile, _inputFile, _errFile will be NULL if no redirection was done,
or the name of the file they are being redirected to.

The variables _currentCommand and _currentCommand are static variables, that is there is only one for the whole class.
These variables are used to build the Command and Simple command during the parsing of the command.

The Command and SimpleCommand classes implement the main data structure we will use in the shell.

https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf

------------------------------------------------------------------------------------------------------------------------
Token recognition :

1. If the end of input is recognized, the current token shall be delimited. If there is no current token, the
end-of-input indicator shall be returned as the token.

2. If the previous character was used as part of an operator and the current character is not quoted and can be used
with the current characters to form and operator, it shall be used as part of that (operator) token.

3. If the previous character was used as part of an operator and the current character cannot be used with the current
characters to form an operator, the operator containing the previous character shall be delimited.

4. If the current character is single quote or double quote, it shall affect quoting for subsequent characters up
to the end of the quoted ext,

https://pubs.opengroup.org/onlinepubs/009604499/utilities/xcu_chap02.html#tag_02_03
------------------------------------------------------------------------------------------------------------------------
Shell grammar :

    Conventions :
    The resulting tokens shall be classified by their immediate context according to the following rules
    (applied in order).
    These rules shall be used to determine what a "token" is that is subject to parsing at the token level.

    1. A <newline> shall be returned as the token identifier NEWLINE.
    2. If the token is an operator, the token identifier for that operator shall result.
    3. If the string consists solely of digits and the delimiter character is one of > or <, the token identifier
    IO_NUMBER shall be returned.
    4. Otherwise, the token identifier TOKEN results.

    Rules:
    1. [Command Name]
    When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, the
    token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the next
    correct token, proceed as abose.
    2. [Redirection to or from filename]
    As specified there, exactly one field can result (or the result is unspecified) and there are additional
    requirements on pathname expansion.
    3. [Redirection from here-document]
    Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the
    here-document that begins after the next <newline>
    4. Check if WORD is a NAME
    5. When the token is exactly the reserved word 'in', the token identifier for 'in' or 'do' shall result,
    respectively. Otherwise, the token WORD shall be returned.
    6. [Assignment preceding command name]
    If the TOKEN does not contain the character '=', rule 1 is applied. Otherwise, 7b shall be applied.
    If the TOKEN contains the equal sign character, ASSIGNMENT_WORD shall be returned.
    7. [NAME in function]
    When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result. Otherwise, when
    the TOKEN meets the requirements for a name, the token identifier NAME shall result.
    8. [Body of function]
    Word expansion and assignment shall never occur, even when when required by the rules abose, when this rule is being
    parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as
    a single WORD consisting only of characters that are exactly he token described.

arg_list :
        arg_list WORD
        | empty
        ;
cmd_and_args:
        WORD arg_list
        ;
pipe_list:
        pipe_list PIPE cmd_and_args
        | cmd_and_args
        ;
io_modifier:
        DGREAT Word
        | GREAT Word
        | LESS Word
        ;
io_modifier_list:
        io_modifier_list io_modifier
        | empty
        ;
command_line:
        pipe_list io_modifier_list background_opt NEWLINE
        | NEWLINE
        | error NEWLINE
        ;
command_list:
        command_list command_line
        ;

https://pubs.opengroup.org/onlinepubs/009604499/utilities/xcu_chap02.html#tag_02_10
------------------------------------------------------------------------------------------------------------------------
https://medium.com/swlh/lets-build-a-linux-shell-part-ii-340ecf471028
------------------------------------------------------------------------------------------------------------------------
Abstract Syntax Tree :

In computer science, an abstract syntax tree is a tree representation of the abstract syntactic structure of text
written in a formal language. Each node of the tree denotes a construct occurring in the text.
The syntax is "abstract" in the sense that is does not represent every detail appearing in the real syntax, but rather
just the strutural or content-related details. For instance, grouping parentheses are implicit in the tree structure,
so these do not have to be represented as separate nodes. Likewise, a syntactic construct like an if-condition-then
statement may be denoted by means of a single node with three branches.
This distinguishes abstract syntax trees from concrete syntax trees, traditionally designated parse trees. Parse trees
are typically built by a parser during the source code translation and compiling process. Once built, additional
information is added to the AST by means of subsequent processing.

https://en.wikipedia.org/wiki/Abstract_syntax_tree
------------------------------------------------------------------------------------------------------------------------
How to communicate between processes?

                                parent
                                   |
                                   |
                                   V
                       _____________________________
                       |   _______________________  |
                       |   | text (instructions) |  |
                       |   |        data         |  |
                       |   -----------------------  |
                       |----------------------------|
                       |   _______________________  |
                       |   | ressources (open    |  |
                       |   |   files, etc...)    |  |
                       |   -----------------------  |
                       |____________________________|
                                    |
                                    |
                                    V
                                 ________
                   --------------|fork()|-------------
                   |             --------            |
                   |                                 |
                   V                                 V
    --------------------------             ---------------------------
    | ----------------------  |            | -----------------------  |
    | | fork() returns the  | | user       | | fork() return 0 in   | | user
    | | PID of the created  | | space      | | the created child    | | space
    | | child in the parent | |            | ---------------------- | |
    |  ---------------------  |write       | -----------------------  |
    |-------------------------|  ==pipe==> |_| the child process is |_|
    | ----------------------- |        read| | a copy of the parent | |
    | | ressources (open    | | kernel     |  ----------------------  | kernel
    | | files, etc)         | | space      |  ----------------------  | space
    | ----------------------- |            |  | ressources (open    | |
    |_________________________|            |  | files, etc)         | |
                                           |   ---------------------  |
                                           ----------------------------


                                  parent
                                    |
                                    |
                                    V
                parent  --------- fork() --------- child
                        |                         |
                        |                         V
                        |                       exec()
                        |                         |
                        V         status          V
                      wait() <----------------- exit()
                        |
                        V
                      parent


https://www.youtube.com/watch?v=Mqb2dVRe0uo&list=PLfqABt5AS4FkW5mOn2Tn9ZZLLDwA3kZUY&index=6
------------------------------------------------------------------------------------------------------------------------
What allows us the stat functions (stat(), fstat(), lstat()) to do?

Every file stores different types of information about themselves :
- type of file
- access permission
- number of hard links of a file
- the file owner user ID
- the file group ID
- the file size in bytes
- the last time the file was accessed
- the last time the file was modified
- the last time the file access permission UID, GID or hard link count was last changed
- the system inode number of the file (unique ID of filesystem)
- the filesystem ID where the file is stored

https://www.youtube.com/watch?v=jOl0ezOuoNE
------------------------------------------------------------------------------------------------------------------------
What is a tty?

A tty is an direct interface between the user and the machine. A terminal is generally just an emulated tty,
that we call a pty.

https://www.howtogeek.com/428174/what-is-a-tty-on-linux-and-how-to-use-the-tty-command/
https://www.youtube.com/watch?v=SYwbEcNrcjI
------------------------------------------------------------------------------------------------------------------------
How to use the termcap library?

- tgetent initialises termcap
- tgetnum displays all numeric datas link to the terminal (cols, rows,...)
- tgetflag returns boolean instead of value
- tgetstr get termcap
- tputs executes termcap
    example :   char *cl_cap = tgetstr("cl", NULL);
                tputs(cl_clap, 1, putchar);

list of the most used termcaps :
- co : number of columns displayed on the screen
- li : number of lines displayed on the screen
- AF : defined color of text
- AB : defined color of background
- md : display text in bold
- us : display text underlined
- mb : display text blinking
- cm : moves cursor to the wished coordinates
- cl : clear the text on the screen
- me : cancel all changes
- os : overstrike, if the terminal erases or not the content when a rewriting (for example backspace)


https://www.gnu.org/software/termutils/manual/termcap-1.3/html_mono/termcap.html
------------------------------------------------------------------------------------------------------------------------
What is termios?

Stores data of communication.
Termios is responsible for :
- Line buffering
- Echo
- Line editing
- Newline translation
- Signal generation
                                input
                ------------------------------------------>
Console ======= master pty ======== termios ====== slave pty ======== shell
                <------------------------------------------
                                output

https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/

_s(s[i], set) && !in_s(s[i + 1], set) && k > 0) && (k = 0) == 0)
			j++;
	}
	tab[count_words(s, set)] = NULL;